
\section{Preliminaries}
\label{sec:preliminaries}

Sequence data structures considered in this paper (for collaborative editing)
belong to the optimistic class of replication~\cite{saito2005optimistic}. Each
replica owner (a collaborator) directly performs operations on its local copy
and informs the other owners by broadcasting these operations. The consistency
criteria ensured by such optimistic replication is called strong eventual
consistency~\cite{shapiro2011comprehensive} upon the assumption of the eventual
delivery of operations, i.e., they guarantee that all replicas will eventually
converge to an identical state when the system becomes quiescent. This
consistency criterion is weaker than sequential consistency and linearisability
and is not comparable with causal consistency, yet strong enough for
collaborative edition~\cite{shapiro2011comprehensive}.

Sequence replicated data structures (\emph{sequence} for short) are the closest
structures that can implement a shared document. A sequence provides two
commutative operations: insert and delete. Operations can be integrated in any
order as soon as the deletion of an element follows its insertion.

The sequence is composed of elements and a unique and immutable identifier is
associated with each of these elements. The sequence can be seen as a set of
pairs $\langle element, identifier \rangle$. A total order is assumed on
identifiers and this order relation allows seeing the set of pairs as a
sequence. The projection of a sequence on the elements builds the document.

When a collaborator performs an insert operation, it first allocates the
identifier of the element to insert. For instance, let us consider a sequence
QWTY with the unique, immutable, and totally ordered integer identifiers $1$,
$2$, $4$, $8$ respectively. A collaborator inserts the element E between W
and T. The natural identifier that comes to mind is $3$. The resulting
sequence is QWETY. However, R cannot be inserted between E and T since
$3$ and $4$ are contiguous. The space of identifiers must be enlarged to handle
the new insertion. If we consider identifiers as decimal numbers, $3.1$ can be
associated with the character R. If a new character has to be inserted
between E and R, a new identifier will be allocated between $3$ and
$3.1$. Again, the space will be extended resulting in a new identifier $3.0$
suffixed by any non null integer. Let $X$ be the suffix, the order is preserved
since $(3 < 3.0.X < 3.1)$.

Such growing identifiers are called variable-size identifiers. The main
objective is to keep the growth of the size of the identifiers under acceptable
boundaries.

\subsection{Variable-size Identifiers}
\label{subsec:variable}

Variable-size identifiers can be represented as a concatenation of basic
elements (e.g. integers). The resulting sequence can be represented by a tree
structure where the elements of the sequence are stored at the nodes and where
the edges of the tree are labelled such that a path from the root to a node
represents the identifier of the element stored at this node. For instance, the
character $R$ in the previous example is accessible following the path composed
of the edges labelled $3$ then $1$. More formally, a sequence is a tree where
each node contains a value i.e. an element of the sequence (over an alphabet
$\mathcal{A}$). The tree is a set of pairs
$\langle\mathcal{P}\subset\{\mathbb{N}\}^*,\, \mathcal{A} \rangle$, i.e., each
element has a path. Additionally, a total order
($\mathcal{P}$,$<_{\mathcal{P}}$) provides an ordering among the paths which
allows to retrieve the order of the elements in the sequence. Notation: a path
composed of $e$ edges labelled $\ell_1,\ell_2,\ldots,\ell_e$ will be noted
$[\ell_1.\ell_2\ldots\ell_e]$.

\begin{figure*}
  \centering
  \subfloat[The tree is the unions of identifiers.]
  [\label{fig:treemodelexample}The tree representing the sequence is
  built by the union of identifiers and mainly uses paths to order its
  characters.]
  {\input{input/treemodelexample.tex}}
  \hspace{20pt}
  \subfloat[Disambiguators operate when same paths have been allocated.]
  [\label{fig:disexample}The tree uses disambiguators to maintain an
  equivalent state, even in presence of concurrent operations resulting
  in same paths.]
  {\input{input/desexample.tex}}
  \caption{Examples of 10-ary trees containing the sequence of characters
    'QWERTY'.}
\end{figure*}


Figure~\ref{fig:treemodelexample} shows the underlying 10-ary tree representing
a sequences. Like in the previous scenario, the initial sequence is QWTY with
the respective paths $[1]$, $[2]$, $[4]$ and $[8]$. The insertion of the
character E between the pairs $\langle [2],\, \text{W}\rangle$ and
$\langle [4],\, \text{T}\rangle$ results in the following pair:
$\langle [3],\, \text{E} \rangle$. Then the insertion of Character R needs to
start a new level since there is no room at the first level of the tree for a
new path between E and T. The resulting path may be $[3.1]$ if label one is
chosen for the element R at the second level. This would increase the depth of
the tree in case there is an insertion between the elements E and R. The new
path would be $[3.0.X]$ where $0<X<10$ (recall that we assume a 10-ary
tree). The total order $(\mathcal{P},\,<_\mathcal{P})$ allows retrieving the
sequence QWERTY.

\subsection{Disambiguation of concurrent cases}
\label{subsec:disambiguation}

Two collaborators concurrently performing an operation on their respective
replica may get different results after the integration of both
operations. Indeed, $(\mathcal{P},\,<_\mathcal{P})$ is a total order when a
single collaborator edits. However, it becomes a partial order when the editing
involves several collaborators. Consequently, it is necessary to totally order
the elements inserted by different collaborators. To this end, the
disambiguation function $\delta$ associates a disambiguator to each pair of
$\mathcal{T}$. $\delta: \mathcal{D} \rightarrow \mathcal{P}\times\mathcal{A}$.
There exists a total order ($\mathcal{D}$, $<_{\mathcal{D}}$) such that elements
of the sequence are always comparable pairwise, even if they have an identical
path due to concurrency. 

Let the identifiers $\mathcal{I}$ be the set of unique triples
$\mathcal{I}:\mathcal{P}\times \mathcal{A}\times \mathcal{D}$. The composition
of the partial order ($\mathcal{P}$, $<_{\mathcal{P}}$) and the total order
($\mathcal{D}$, $<_{\mathcal{D}}$) allows ordering the elements of the sequence
identically at any replica.

Figure~\ref{fig:disexample} depicts a tree containing 6 elements with only 5
distinct paths (two values are associated with the path $[3]$). Similarly to the
previous example, the initial sequence was QWTY, however, in this example, the
two elements E and R are inserted between the pairs
$\langle [2],\, \text{W}\rangle$ and $\langle [4],\, \text{T}\rangle$ by two
different collaborators concurrently. For both elements, the resulting path is
$[3]$. After the two elements are inserted, the sequence becomes either QWERTY
or QWRETY. Nevertheless, let the identifiers
$\langle [3],\, \text{R},\, \delta_\text{R}\rangle$ and
$\langle [3],\, \text{T},\, \delta_\text{T} \rangle$. Assuming that
$\delta_\text{R} <_\mathcal{D} \delta_\text{T}$, the total order
$(\mathcal{I}, <_\mathcal{I})$ gives the sequence QWERTY. It is worth noting
that disambiguators are usually computed using a monotonically increasing
variable and a unique collaborator identifier just like Lamport
timestamps~\cite{lamport1978time}. Therefore, a collaborator cannot directly
influence the final position of the character in the sequence using
disambiguators. The sequence of the example could have ended in QWRETY and it
would have needed a correction. Also, the space complexity of disambiguators is
bounded by their associated path. Therefore, we focus on paths in the rest of
the paper.

\subsection{Choosing the rightful path}
\label{subsec:choosing}

The most critical part of sequences with variable-size identifiers consists in
creating the paths. Algorithm~\ref{algo:crdtabstract} shows the general outlines
of these sequences. It divides the operations -- insert and delete -- into the
local and remote parts of the optimistic replication scheme. We can see that the
core of the algorithm and associated complexity lies in the local part of the
insert operation where it generates a path (cf. Line~\ref{line:allocpath}) and a
disambiguator (cf. Line~\ref{line:allocdes}). Function \textsc{convert2Path}
gets rid of the disambiguators of the identifiers in argument to keep paths
only. Without evidence of concurrency, it simply returns the paths contained in
the identifiers. Otherwise, it translates the identifiers into paths that
maintain the order following the order of paths
($\mathcal{P},\, <_{\mathcal{P}}$) For instance in Figure~\ref{fig:disexample},
the result of \textsc{convert2Path} with the identifiers of Character E and
Character R is the pair $\langle [3.0],\, [3.9]\rangle$. Function
\textsc{allocPath} allocates a new path between these bounds. Function
\textsc{allocDis} decorates the path in order to guarantee that the new
identifier -- as the composition of a path, an element, and a disambiguator --
consistently fall between the adjacent identifiers that served to create it
following the order of identifiers ($\mathcal{I}, \, <_\mathcal{I}$).

\begin{algorithm}[h]
  \input{input/crdtabstractalgo.tex}
  \caption{\label{algo:crdtabstract}General outlines of a sequence with
    variable-size identifiers.}
\end{algorithm}

Function \textsc{allocPath} chooses a path in the tree between two other paths
$p$ and $q$ where $p$ precedes $q$: $p<_{\mathcal{P}}q$. The new path $n$ must
fall inbetween $p$ and $q$: $p<_\mathcal{P}n<_\mathcal{P}q$. However, the number
of paths between two paths is infinite, for the order is dense, and so is the
number of \textsc{allocPath} strategies. Nevertheless, Function
\textsc{allocPath} should choose the smallest available path among all the
possible paths for performance sake. This observation reduces considerably the
number of possible allocation strategies. Still, the allocation of paths without
an \emph{a priori} knowledge of the final sequence is a non-trivial problem.

\begin{figure*}
  \centering
  \subfloat[Optimal case.]
  [Optimal case.]
  {\input{input/allocpathexampleA.tex}}
  \hspace{50pt}
  \subfloat[Worst case.]
  [Worst case.]
  {\input{input/allocpathexampleB.tex}}
  \caption{\label{fig:allocpathexample} Two trees filled with the resulting
    identifiers of two different permutations resulting in an identical sequence
    QWERTY. They use the same function \textsc{allocPath} which allocates the
    leftmost branch in the tree. All paths of the nearly optimal case have a
    length of 1 while the tree of the worst case grows up to a depth of 6.}
\end{figure*}

Figure~\ref{fig:allocpathexample} illustrates the difficulties of designing a
function allocating paths. It represents the underlying trees of two sequences
using the allocation function that allocates the leftmost branch available at
the lowest depth possible. In both cases the final sequence is QWERTY. However,
the insertion order of characters is different. In the first case, Q is inserted
first at position 0, followed by W at position 1 (after Q) then E is inserted at
position 3 (after W), etc. We call the sequence of insert operations
$[(\text{Q},\,0)$, $(\text{W},\,1)$, $(\text{E},\,2)$, $\ldots]$ the
\emph{editing sequence}. In the second case, Character Y is inserted first at
position 0 as the sequence is initially empty. Then T is inserted. However as
the final intended word is QWERTY, T has to be inserted at a position before Y
that represents the current state of the sequence. T is thus inserted at
position 0 shifting Character Y to position 1, etc. The editing sequence that
corresponds to this case is $[(\text{Y},\,0)$, $(\text{T},\,0)$,
$(\text{R},\,0)$, $\ldots]$.


\begin{itemize}
\item Case 1: Since Function \textsc{allocPath} allocates the leftmost branches,
  the following editing sequence $[(\text{Q},\,0)$, $(\text{W},\,1)$,
  $(\text{E},\,2)$, $\ldots]$ leads to the paths
  $\langle [1],\, \text{Q}\rangle$, $\langle [2],\, \text{W}\rangle$,
  $\langle [3],\, \text{E}\rangle$, etc. In this case, the depth of the tree
  never grows. In this regard, the strategy of \textsc{allocPath} is very
  efficient in terms of the size of the allocated identifiers.

\item Case 2: The editing sequence $[(\text{Y},\,0)$, $(\text{T},\,0)$,
  $(\text{R},\,0)$, $\ldots]$ leads to an increase of the tree depth per
  insertion. Indeed, as an element gets the smallest value at its level, there
  is no room for a new element at the same level, hence a new level. The
  resulting sequence is $\langle [1],\, \text{}Y\rangle$,
  $\langle [0.1],\, \text{T}\rangle$, $\langle [0.0.1],\, \text{R} \rangle$,
  etc. Consequently, the paths grow very fast.
\end{itemize}

This example shows how the insertion order impacts the length of the allocated
paths. Unfortunately, the insertion order cannot be predicted, nor the size of
the final sequence. Prior work on sequences often made the assumption of a
left-to-right editing due to observations made on
corpus~\cite{preguica2009commutative, weiss2009logoot}. However, there exist
human edited documents that do not correspond to this kind of
editing~\cite{nedelec2013lseq}.
%% Indeed, the editing depends on the type of the document and to the activity
%% for example when correcting a document the editing in mainly random as the
%% insertions and deletions corresponds to errors distributed in the document.
We are looking for an allocation function which provides identifiers with a
sublinear space complexity compared to the number of insertions whatever the
editing sequence. Such allocation function would avoid the need for consensus
algorithm and would make CRDT-based editors a practicable alternative to the
current mainstream editors.
 
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
