
\section{Preliminaries}
\label{sec:preliminaries}

Sequence replicated data structures (\emph{sequence} for short) are the closest
structures that can implement a shared document. A sequence provides two
commutative operations: insert and delete. Operations can be integrated in any
order as soon as the deletion of an element follows its insertion.

The sequence is composed of elements and a unique and immutable identifier is
associated with each of these elements. The sequence can be seen as a set of
pairs $\langle element, identifier \rangle$. A total order is assumed on
identifiers and this order relation allows seeing the set of pairs as a
sequence. The projection of a sequence on the elements builds the document.

When a collaborator performs an insert operation, it first allocates the
identifier of the element to insert. For instance, let us consider a sequence
QWTY with the unique, immutable, and totally ordered integer identifiers $1$,
$2$, $4$, $8$ respectively. A collaborator inserts the element E between W and
T. The natural identifier that comes to mind is $3$. The resulting sequence is
QWETY. However, R cannot be inserted between E and T since $3$ and $4$ are
contiguous. The space of identifiers must be enlarged to handle the new
insertion. If we consider identifiers as decimal numbers, $3.1$ can be
associated with the character R. If a new character has to be inserted between E
and R, a new identifier will be allocated between $3$ and $3.1$. Again, the
space will be extended resulting in a new identifier $3.0$ suffixed by any non
null integer. Let $X$ be this suffix, the order of the elements of the sequence
is preserved since $(3 < 3.0.X < 3.1)$.

Such growing identifiers are called variable-size identifiers. The main
objective is to keep the growth of the size of the identifiers under a sublinear
boundary.

\subsection{Variable-size Identifiers}
\label{subsec:variable}

Variable-size identifiers can be represented as a concatenation of basic
elements (e.g. integers). The resulting sequence can be represented by a tree
structure where the elements of the sequence are stored at the nodes and where
the edges of the tree are labeled such that a path from the root to a node
represents the identifier of the element stored at this node. For instance, the
character $R$ in the previous example is accessible following the path composed
of the edges labeled $3$ then $1$. More formally, a sequence is a tree where
each node contains a value i.e. an element of the sequence (over an alphabet
$\mathcal{A}$). The tree is a set of pairs
$\langle\mathcal{P}\subset\{\mathbb{N}\}^*,\, \mathcal{A} \rangle$, i.e., each
element is associated with a path. Additionally, a total order
($\mathcal{P}$,$<_{\mathcal{P}}$) provides an ordering among the paths which
allows to retrieve the order of the elements in the sequence. Notation: a path
composed of $e$ edges labeled $\ell_1,\ell_2,\ldots,\ell_e$ will be noted
$[\ell_1.\ell_2\ldots\ell_e]$.

\begin{figure*}
  \centering
  \subfloat[The tree is the unions of identifiers.]
  [\label{fig:treemodelexample}The tree representing the sequence is
  built by the union of identifiers and mainly uses paths to order its
  characters.]
  {\input{input/treemodelexample.tex}}
  \hspace{20pt}
  \subfloat[Disambiguators operate when same paths have been allocated.]
  [\label{fig:disexample}The tree uses disambiguators to maintain an
  equivalent state, even in presence of concurrent insertions resulting
  in same paths. For simplicity sake, only the disambiguators of E, R, and T 
  are displayed.]
  {\input{input/desexample.tex}}
  \caption{Examples of 10-ary trees containing the sequence of characters
    QWERTY.}
\end{figure*}


Figure~\ref{fig:treemodelexample} shows the underlying 10-ary tree representing
a sequence. Like in the previous scenario, the initial sequence is QWTY with
the respective paths $[1]$, $[2]$, $[4]$ and $[8]$. The insertion of the
character E between the pairs $\langle [2],\, \text{W}\rangle$ and
$\langle [4],\, \text{T}\rangle$ results in the following pair:
$\langle [3],\, \text{E} \rangle$. Then the insertion of Character R needs to
start a new level since there is no room at the first level of the tree for a
new path between E and T. The resulting path may be $[3.1]$ if label $1$ is
chosen for the element R at the second level. This would increase the depth of
the tree in case there is an insertion between the elements E and R. The new
path would be $[3.0.X]$ where $0<X<10$ (recall that we assume a 10-ary
tree). The total order $(\mathcal{P},\,<_\mathcal{P})$ allows retrieving the
sequence QWERTY.

\subsection{Disambiguation of concurrent cases}
\label{subsec:disambiguation}

% Two collaborators concurrently performing an operation on their respective
% replica may get different results after the integration of both
% operations. Indeed,
The order among paths $(\mathcal{P},\,<_\mathcal{P})$ is a total order when a
single collaborator edits. However, it becomes a partial order when the editing
session involves several collaborators. For instance, two collaborators
inserting a character at a same position in the sequence and at a same time may
end up with the same path. In such case the order of characters is not strictly
defined and may break the convergence property. Disambiguators use globally
unique markers to provide a total order among elements even in presence of
concurrent insertions. These markers usually comprise unique site identifiers
along with Lamport clocks~\cite{lamport1978time}. Each pair of
$\langle element,\,path\rangle$ is associated with a disambiguator.

Let the set of identifiers $\mathcal{I}$ be the set of unique triples
$\mathcal{I}:\mathcal{P}\times \mathcal{A}\times \mathcal{D}$. The composition
of the partial order ($\mathcal{P}$, $<_{\mathcal{P}}$) and the total order of
disambiguators ($\mathcal{D}$, $<_{\mathcal{D}}$) orders the elements of the
sequence identically at any replica.

Figure~\ref{fig:disexample} depicts a tree containing 6 elements with only 5
distinct paths. First, Collaborator $c_1$ inserts QW.  Then, the collaborators
$c_1$ and $c_2$ concurrently insert respectively E and T which happens to
generate an identical path: [$3$]. To solve the order ambiguity, the
disambiguator $\langle c_1,\, 3\rangle$ is associated with E; the disambiguator
$\langle c_2,\, 1\rangle$ is associated with T. Retrieving the order of elements
simply consists in comparing at each level the paths, then the site identifiers,
then the clocks. In this example, the character E precedes the character T
because $c_1 < c_2$. Then, Collaborator $c_1$ inserts Y at the end of the
sequence. Finally, she inserts R between E and T. Since E and T have an
identical path, there is not enough room for new insertions at this level. The
allocation function chooses a path [$3.X$] where $0<X<10$. By copying the
disambiguator of E at the first level, it ensures that the new identifier will
follow the character E and precede the character T.  Collaborators cannot
influence the final position of the character in the sequence using
disambiguators, for disambiguators are automatically computed without concerns
about positions. The sequence of the example could have ended in QWTREY and it
would have needed a correction. It is worth noting that the space complexity of
disambiguators is upper-bounded by their respective path. Therefore, we focus on
paths in the rest of the paper.


% Similarly to the previous example, the initial sequence was QWTY, however, in
% this example, the two elements E and R are inserted between the pairs
% $\langle [2],\, \text{W}\rangle$ and $\langle [4],\, \text{T}\rangle$ by two
% different collaborators concurrently. For both elements, the resulting path is
% $[3]$. After the two elements are inserted, the sequence becomes either QWERTY
% or QWRETY. Nevertheless, let the identifiers
% $\langle [3],\, \text{R},\, \delta_\text{R}\rangle$ and
% $\langle [3],\, \text{T},\, \delta_\text{T} \rangle$. The use of disambiguators
% $\delta_{\text{R}}$ and $\delta_{\text{T}}$ allows retrieving the sequence
% QWERTY. It is worth noting that disambiguators are usually computed using a
% monotonically increasing variable and a unique collaborator identifier just like
% Lamport timestamps~\cite{lamport1978time}.


\subsection{Choosing the rightful path}
\label{subsec:choosing}

The most critical part of sequences with variable-size identifiers consists in
creating the paths. Algorithm~\ref{algo:crdtabstract} shows the general outlines
of these sequences. It divides the operations -- insert and delete -- into the
local and remote parts of the optimistic replication scheme. We can see that the
core of the algorithm and associated complexity lies in the local part of the
insert operation where it generates a path (cf. Line~\ref{line:allocpath}) and a
disambiguator (cf. Line~\ref{line:allocdes}). The function \textsc{convert2Path}
gets rid of the disambiguators of the identifiers in argument to keep paths
only. Without evidence of concurrency, it simply returns the paths contained in
the identifiers. Otherwise, it translates the identifiers into paths that
maintain the order following the order of paths
($\mathcal{P},\, <_{\mathcal{P}}$). For instance in Figure~\ref{fig:disexample},
the result of \textsc{convert2Path} with the identifiers of Character E and
Character T is the pair $\langle [3.0],\, [3.9]\rangle$. The function
\textsc{allocPath} allocates a new path between these bounds.  \textsc{allocDis}
decorates the path in order to guarantee that the new identifier -- as the
composition of a path, an element, and a disambiguator -- consistently fall
between the adjacent identifiers that served to create it following the order of
identifiers ($\mathcal{I}, \, <_\mathcal{I}$).

\begin{algorithm}[h]
  \input{input/crdtabstractalgo.tex}
  \caption{\label{algo:crdtabstract}General outlines of a sequence with
    variable-size identifiers.}
\end{algorithm}

The function \textsc{allocPath} chooses a path in the tree between two other paths
$p$ and $q$ where $p$ precedes $q$: $p<_{\mathcal{P}}q$. The new path $n$ must
fall between $p$ and $q$: $p<_\mathcal{P}n<_\mathcal{P}q$.
% However, the number of paths between two paths is infinite, for the order is
% dense, and so is the number of \textsc{allocPath} strategies. Nevertheless,
The function \textsc{allocPath} should choose the smallest available path among all
the possible paths for performance sake.
% This observation reduces considerably the number of possible allocation
% strategies.

\begin{figure*}
  \centering
  \subfloat[Optimal case.]
  [\label{fig:allocpathexampleA} Optimal case.]
  {\input{input/allocpathexampleA.tex}}
  \hspace{50pt}
  \subfloat[Worst case.]
  [\label{fig:allocpathexampleB} Worst case.]
  {\input{input/allocpathexampleB.tex}}
  \caption{\label{fig:allocpathexample} Two trees filled with the resulting
    identifiers of two different permutations resulting in an identical sequence
    QWERTY. The function \textsc{allocPath} allocates the leftmost branch in the
    tree. All paths of the optimal case have a length of 1 while the tree of the
    worst case grows up to a depth of 6.}
\end{figure*}

As illustrated in Figure~\ref{fig:allocpathexample}, the allocation of paths
without an \emph{a priori} knowledge of the final sequence is a non-trivial
problem.  Suppose that \textsc{allocPath} allocates the leftmost branch
available at the lowest depth possible. Suppose two insertion orders resulting
in an identical sequence of characters QWERTY.  In the first case, Q is inserted
first at position 0, followed by W at position 1 (after Q) then E is inserted at
position 3 (after W), etc.  In the second case, Y is inserted first at position
0 as the sequence is initially empty. Then T is inserted. However as the final
intended word is QWERTY, T has to be inserted at a position before Y that
represents the current state of the sequence. T is thus inserted at position 0
shifting Character Y to position 1, etc.


\begin{itemize}[noitemsep, leftmargin=*]
\item Figure~\ref{fig:allocpathexampleA}: In this case, the insertion order
  exactly follows the expectations of the allocation function. The depth of the
  tree never grows. The execution of operations remain efficient.

\item Figure~\ref{fig:allocpathexampleB}: In this case, the insertion order goes
  against the expectations of the allocation function. The depth of the tree
  increase at each insertion. Indeed, as an element gets the smallest value at
  its level, there is no room for a new element at the same level, hence the
  creation of a new level. The depth of the tree grows very fast decreasing the
  efficiency of operations.
\end{itemize}

This example shows how the insertion order impacts the length of the allocated
paths. Unfortunately, the insertion order cannot be predicted, nor the size of
the final sequence. Prior work on sequences often made the assumption of a
left-to-right editing due to observations made on
corpora~\cite{preguica2009commutative, weiss2009logoot}. However, there exist
human edited documents that do not correspond to this kind of
editing~\cite{nedelec2013lseq}.
%% Indeed, the editing depends on the type of the document and to the activity
%% for example when correcting a document the editing in mainly random as the
%% insertions and deletions corresponds to errors distributed in the document.
Hence the need of an allocation function which provides identifiers with a
sublinear space complexity compared to the number of insertions whatever is the
editing sequence. Such allocation function would avoid the need for consensus
algorithm~\cite{mostefaoui2015signature} and would make CRDT-based editors a
practicable alternative to the current mainstream editors.
 
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
